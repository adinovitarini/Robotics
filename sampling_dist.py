# -*- coding: utf-8 -*-
"""Sampling_dist.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pOrgHUq520sKqsoT6KRalfiQD8lgrlCJ
"""

import math
import numpy as np
import scipy.stats
import timeit
import matplotlib.pyplot as plt
def sample_normal_twelve(mu, sigma):
  """ Sample from a normal distribution using 12 uniform samples.
  See lecture on probabilistic motion models slide 19 for details.
  """
  # Formula returns sample from normal distribution with mean = 0
  x = 0.5 * np.sum(np.random.uniform(-sigma, sigma, 12))
  return mu + x
def sample_normal_rejection(mu, sigma):
  """Sample from a normal distribution using rejection sampling.
  See lecture on probabilistic motion models slide 25 for details.
  """
  # Length of interval from wich samples are drawn
  interval = 5*sigma
  # Maximum value of the pdf of the desired normal distribution
  max_density = scipy.stats.norm(mu,sigma).pdf(mu)
  # Rejection loop
  while True:
    x = np.random.uniform(mu - interval, mu + interval, 1)[0]
    y = np.random.uniform(0, max_density, 1)
    if y <= scipy.stats.norm(mu, sigma).pdf(x):
      break
  return x
def sample_normal_boxmuller(mu, sigma):
  """Sample from a normal distribution using Box-Muller method.
  See exercise sheet on sampling and motion models.
  """
  # Two uniform random variables
  u = np.random.uniform(0, 1, 2)
  # Box-Muller formula returns sample from STANDARD normal distribution
  x = math.cos(2*np.pi*u[0]) * math.sqrt(-2*math.log(u[1]))
  return mu + sigma * x
def evaluate_sampling_time(mu, sigma, n_samples, sample_function):
  tic = timeit.default_timer()
  for i in range(n_samples):
    sample_function(mu, sigma)
  toc = timeit.default_timer()
  time_per_sample = (toc - tic) / n_samples * 1e6
  print("%30s : %.3f us" % (sample_function.__name__, time_per_sample))
def evaluate_sampling_dist(mu, sigma, n_samples, sample_function):
  n_bins = 100
  samples = []
  for i in range(n_samples):
    samples.append(sample_function(mu, sigma))
  print("%30s : mean = %.3f, std_dev = %.3f" % (sample_function.__name__, np.mean(samples), np.std(samples)))
  plt.figure()
  count, bins, ignored = plt.hist(samples, n_bins, normed=True)
  plt.plot(bins, scipy.stats.norm(mu, sigma).pdf(bins), linewidth=2, color='r')
  plt.xlim([mu - 5*sigma, mu + 5*sigma])
  plt.title(sample_function.__name__)
def main():
  mu, sigma = 0, 1
  sample_functions = [sample_normal_twelve,sample_normal_rejection,sample_normal_boxmuller,np.random.normal]
  for fnc in sample_functions:
    evaluate_sampling_time(mu, sigma, 1000, fnc)
  n_samples = 10000
  print("evaluting sample distances with:" )
  print(" mean :", mu)
  print(" std_dev :", sigma)
  print(" samples :", n_samples)
  for fnc in sample_functions:
    evaluate_sampling_dist(mu, sigma, n_samples, fnc)
  plt.show()
if __name__ == "__main__":
  main()